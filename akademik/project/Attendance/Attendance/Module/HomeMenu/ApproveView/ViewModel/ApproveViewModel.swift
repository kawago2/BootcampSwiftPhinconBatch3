//
//  ApproveViewModel.swift
//  Attendance
//
//  Created by Phincon on 29/12/23.
//

import Foundation

// MARK: - ApproveViewModel

class ApproveViewModel {
    var permissionData: [PermissionForm] = []
    var completedPermission: [PermissionForm] = []
    var currentSortBy = ""
    
    // MARK: - Data Fetching
    
    func getData(completionHandler: @escaping (Result<Void, Error>) -> Void) {
        permissionData = []
        let collectionGroupPath = "data"
        
        FirebaseManager.shared.getAllDocumentsFromSubcollection(collectionGroupPath: collectionGroupPath) { result in
            switch result {
            case .success(let documents):
                for document in documents {
                    let data = document.data()
                    var permissionForm = PermissionForm()
                    permissionForm.fromDictionary(dictionary: data)
                    self.permissionData.append(permissionForm)
                }
                completionHandler(.success(()))
            case .failure(let error):
                completionHandler(.failure(error))
            }
        }
    }
    
    // MARK: - Approval Logic
    
    func approveLogic(forRowAt indexPath: IndexPath, completionHandler: @escaping (Result<Void, Error>) -> Void) {
        let permissionItem = completedPermission[indexPath.row]
        let collection = "permissions"
        let subCollection = "data"
        
        let currentDate = Date()
        let dataUpdate: [String: Any] = [
            "approvalTime" : currentDate,
            "status" : PermissionStatus.approved.rawValue
        ]
        
        if let uid = permissionItem.applicantID, let id = permissionItem.autoGeneratedID {
            FirebaseManager.shared.editDataInSubcollection(documentID: uid, inCollection: collection, subcollectionPath: subCollection, documentIDToEdit: id, newData: dataUpdate) { result in
                switch result {
                case .success:
                    completionHandler(.success(()))
                case .failure(let error):
                    completionHandler(.failure(error))
                }
            }
        }
    }
    
    // MARK: - Rejection Logic
    
    func rejectLogic(forRowAt indexPath: IndexPath, completionHandler: @escaping (Result<Void, Error>) -> Void) {
        let permissionItem = completedPermission[indexPath.row]
        let collection = "permissions"
        let subCollection = "data"
        
        let currentDate = Date()
        let dataUpdate: [String: Any] = [
            "approvalTime" : currentDate,
            "status" : PermissionStatus.rejected.rawValue
        ]
        
        if let uid = permissionItem.applicantID, let id = permissionItem.autoGeneratedID {
            FirebaseManager.shared.editDataInSubcollection(documentID: uid, inCollection: collection, subcollectionPath: subCollection, documentIDToEdit: id, newData: dataUpdate) { result in
                switch result {
                case .success:
                    completionHandler(.success(()))
                case .failure(let error):
                    completionHandler(.failure(error))
                }
            }
        }
    }
    
    // MARK: - Sorting Methods
    
    func sortByStatus(sortby: String) {
        switch sortby.lowercased() {
        case PermissionStatus.approved.rawValue.lowercased():
            completedPermission = permissionData.filter { $0.status == .approved }
        case PermissionStatus.rejected.rawValue.lowercased():
            completedPermission = permissionData.filter { $0.status == .rejected }
        case PermissionStatus.submitted.rawValue.lowercased():
            completedPermission = permissionData.filter { $0.status == .submitted }
        default:
            completedPermission = permissionData
        }
    }

    func sortByDate(sortby: String) {
        switch sortby {
        case DateSortOption.oldest.rawValue.lowercased():
            completedPermission = completedPermission.sorted { $0.permissionTime ?? Date() < $1.permissionTime ?? Date() }
        case DateSortOption.newest.rawValue.lowercased():
            completedPermission = completedPermission.sorted { $0.permissionTime ?? Date() > $1.permissionTime ?? Date() }
        default:
            break
        }
    }
}
